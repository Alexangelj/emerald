# @title Instrument Controller
# 
# @notice Controls specification, creation, and management of financial instruments and vehicles.
# 
# @author Alexander Angel
# 
# @dev System Controller is the management contract of this contract.
#
# @version 0.1.0b14
#
# @system Contract Hierarchy
#   Instrument Controller
#       Instrument Registry    
#           Asset Registry
#               Set Registry
#                   Parent Asset Factory
#                   Parent Set Factory
#                       Parent Token Factory
#                           Asset
#                               Set
#                                   Year
#                                       Month
#                                           Day
#   ========================================================
#                                               ERC-20 Token




struct Set:
    expiration: timestamp[4] # UNIX timestamp

struct Asset: # ERC-20 Token
    name: string[64]
    symbol: string[64]
    decimals: uint256
    assetAddress: address

struct Token:
    symbol: string[64]
    strike: Asset
    underlying: Asset
    expiration: timestamp
    taddress: address

struct AssetPair: # Entangles two Assets
    strike_asset: Asset
    underlying_asset: Asset
    ratio: uint256 # Amount of strike tokens relative to 1 underlying token

struct Instrument:
    symbol: string[64] # String to represent the instrument
    assets: AssetPair # Assets that the instrument is in charge of
    set: Set # Set that the instrument is a part of (A cohort)
    iaddress: address

struct InstrumentRegistry:
    symbol: string[64] # String to represent types of instruments
    instruments: address[16]
    #instruments: map(uint256, Instrument) # Maps an id number to an instrument a part of that registry

#struct AssetFactory:
#    symbol: uint256 # Symbol to Id
#    assets: map(uint256, AssetPair) # Asset pairs generated by factory
#    facAddress: address
#
#struct SetFactory: 
#    symbol: uint256
#    sets: map(uint256, Set) # Sets generated by factory
#    facAddress: address
#
#struct TokenFactory:
#    symbol: uint256
#    Tokens: map(uint256, Token) # Tokens generated by factory
#    facAddress: address
#
#struct InstrumentFactory:
#    symbol: uint256
#    instruments: map(uint256, Instrument) # Instruments generated by factory
#    facAddress: address

struct FactoryRegistry:
    symbol: string[64]
    asset: address
    set: address
    token: address
    instrument: address

struct Registry:
    symbol: string[64]
    factories: FactoryRegistry
    instruments: InstrumentRegistry

contract AssetFactory():
    def name() -> string[64]:constant
    def createPair(_symbol: string[64], _strike: address, _underlying: address, _ratio: uint256) -> AssetPair:modifying
    def getStrikeAsset(_symbol: string[64]) -> (string[64], string[64], uint256, address):modifying
    def strikeAsset(_symbol: string[64]) -> Asset:modifying

contract SetFactory():
    def name() -> string[64]:constant
    def createSet(_symbol: string[64], _epoch: timestamp, _cycle: uint256) -> Set: modifying

contract TokenFactory():
    def name() -> string[64]:constant
    def createToken(
        _name: string[64],
        _symbol: string[64],
        _decimals: uint256,
        _supply: uint256,
        _template: address,
        _expiration: timestamp,
    ) -> address:modifying


contract InstrumentFactory():
    def name() -> string[64]:constant
    def createInstrument(
        _name: string[64],
        _symbol: string[64],
        _ratio: uint256,
        _saddr: address,
        _uaddr: address,
        _set: timestamp[4]
    ) -> address:modifying

contract Erc20():
    def totalSupply() -> uint256:constant
    def balanceOf(_owner: address) -> uint256:constant
    def allowance(_owner: address, _spender: address) -> uint256:constant
    def transfer(_to: address, _value: uint256) -> bool:modifying
    def transferFrom(_from: address, _to: address, _value: uint256) -> bool:modifying
    def approve(_spender: address, _value: uint256) -> bool:modifying
    def name() -> string[64]:constant
    def symbol() -> string[64]:constant
    def decimals() -> uint256:constant

# Interfaces





# Events


Payment: event({_from: indexed(address), _value: wei_value})


# CONSTANTS

MONTH_IN_SECONDS: constant(uint256) = 604800



# State Variables


administrator: public(address)
depreciation: public(timestamp)


sets: public(map(string[64], Set))
assets: map(string[64], map(uint256, Asset)) # Maps a string to two assets: [0] = strike, [1] = underlying
tokens: public(map(string[64], Token))
assetPair: public(map(string[64], AssetPair))
instruments: public(map(string[64], Instrument))

instrumentFactory: InstrumentFactory
assetFactory: AssetFactory
setFactory: SetFactory
tokenFactory: TokenFactory
factoryRegistry: FactoryRegistry
instrumentsRegistry: InstrumentRegistry
registry: Registry




# Fallback and Utility Functions


@public
@payable
def __default__():
    log.Payment(msg.sender, msg.value)


# Core Functions

# Create Instrument
#   Add to Instrument Registry
#       Instrument Factory
#           Assets
#               Sets
#                   Token Factory
#                       Tokens


@public
def __init__(   _instrumentFactory: address,
                _tokenFactory: address,
                _assetFactory: address,
                _setFactory: address,
                _depreciation: timestamp,
                _symbol: string[64],
            ):
    
    self.administrator = msg.sender
    self.depreciation = _depreciation
    self.instrumentFactory = InstrumentFactory(_instrumentFactory)
    self.assetFactory = AssetFactory(_assetFactory)
    self.setFactory = SetFactory(_setFactory)
    self.tokenFactory = TokenFactory(_tokenFactory)
    self.factoryRegistry = FactoryRegistry({symbol: _symbol, asset: _assetFactory, set: _setFactory, token: _tokenFactory, instrument: _instrumentFactory})
    self.registry = Registry({symbol: _symbol, factories: self.factoryRegistry, instruments: self.instrumentsRegistry})


@private
def createAssetPair(_symbol: string[64], _strikeAddress: address, _underlyingAddress: address, _ratio: uint256) -> bool:
    """
    @dev Creates an asset pair to use in an instrument
    """
    strikeName: string[64] = Erc20(_strikeAddress).name()
    strikeSymbol: string[64] = Erc20(_strikeAddress).symbol()
    strikeDecimals: uint256 = Erc20(_strikeAddress).decimals()
    self.assets[_symbol][0] = Asset({
        name: strikeName, 
        symbol: strikeSymbol, 
        decimals: strikeDecimals,
        assetAddress: _strikeAddress,
        })
    underlyingName: string[64] = Erc20(_underlyingAddress).name()
    underlyingSymbol: string[64] = Erc20(_underlyingAddress).symbol()
    underlyingDecimals: uint256 = Erc20(_underlyingAddress).decimals()
    self.assets[_symbol][1] = Asset({
        name: underlyingName, 
        symbol: underlyingSymbol, 
        decimals: underlyingDecimals,
        assetAddress: _underlyingAddress,
        })

    self.assetPair[_symbol] = AssetPair({
        strike_asset: self.assets[_symbol][0],
        underlying_asset: self.assets[_symbol][1],
        ratio: _ratio
    })
    return True


@private
def createToken(_symbol: string[64], _tokenTemplate: address, _expiration: timestamp) -> bool:
    #_set: Set = self.sets[_symbol]
    _saddr: Asset = self.assetPair[_symbol].strike_asset
    _uaddr: Asset = self.assetPair[_symbol].underlying_asset
    self.tokens[_symbol] = Token({
        symbol: _symbol,
        strike: _saddr,
        underlying: _uaddr,
        expiration: _expiration,
        taddress: self.tokenFactory.createToken(
                _symbol, # Name
                _symbol, # Symbol
                convert(18, uint256), # Decimals
                convert(0, uint256), # Initial Amt
                _tokenTemplate, # Address of erc 20 token contract
                _expiration,
            ),
    })
    return True

@public
def createInstrument(
        _symbol: string[64], 
        _strikeAddress: address,
        _underlyingAddress: address, 
        _ratio: uint256,
        _tokenTemplate: address
    ) -> bool:
    """
    @dev Creates a new instrument with an asset pair, sets, and tokens
    """
    self.sets[_symbol] = self.setFactory.createSet(_symbol, self.depreciation, MONTH_IN_SECONDS)
    self.createAssetPair(_symbol, _strikeAddress, _underlyingAddress, _ratio)

    _set: Set = self.sets[_symbol]
    _assets: AssetPair = self.assetPair[_symbol]
    _saddr: Asset = self.assetPair[_symbol].strike_asset
    _uaddr: Asset = self.assetPair[_symbol].underlying_asset
    
    self.instruments[_symbol] = Instrument({
        symbol: _symbol,
        assets: _assets,
        set: _set,
        iaddress: self.instrumentFactory.createInstrument(
                _symbol,
                _symbol,
                _ratio,
                _saddr.assetAddress,
                _uaddr.assetAddress,
                self.sets[_symbol].expiration
            )
        })
    
    self.createToken(_symbol, _tokenTemplate, _set.expiration[1])
    return True